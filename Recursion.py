# -*- coding: utf-8 -*-

"""
  The designers of Python made an intentional decision to limit recursion, typical default value is 1000.
You can be dynamically reconfigured to change the default recursive limit.
    import sys
    default_limit = sys.getrecursionlimit()
    sys.getrecursionlimit(99999)

"""

draw_line_instruction = """
    Draw Line Problem
    The work is done by the recursive draw interval function.
This function draws the sequence of minor ticks within some
interval, based upon the length of the interval’s central tick.
We rely on the intuition shown at the top of this page, and
with a base case when L = 0 that draws nothing.For L ≥ 1, the
first and last steps are performed by recursively calling
draw interval(L − 1).The middle step is performed by calling
the function draw line(L).
"""
x = 0


def draw_line(tick_length, tick_label='.'):
    """Draw one line with given tick length (followed by optional label)."""
    global x
    print(tick_length)
    line = '_' * tick_length
    if tick_label:
        line += '' + tick_label
        print(line)
        x += 1
        print('execute draw_line num is ', x)


def draw_interval(center_length):
    """Draw tick interval based upon a central tick length."""
    if center_length > 0:
        draw_interval(center_length - 1)
        draw_line(center_length)
        draw_interval(center_length - 1)


def draw_rule(num_inches, major_length):
    """Draw English ruler with given number of inches, major tick length."""
    draw_line(major_length, 't')          # Honestly, this line of code shouldn't execute if we want see the law.
    for j in range(1, 1 + num_inches):
        draw_interval(major_length - 1)
        draw_line(major_length, str(j))   # Honestly, this line of code shouldn't execute if we want see the law.


draw_rule(1, 6)

draw_line_summary = '''
number of appear digit
5 - 1
4 - 2
3 - 4
2 - 8
1 - 16

    the number of lines printed by draw interval(c) is one more than twice the number generated by a call to draw
interval(c−1), as one center line is printed between two such recursive calls. By induction, we have that the number of
lines is thus 1+2·(2c−1 −1) = 1+2c −2 = 2c −1.
'''

#####################################################

binary_search = """Another function about recursion in 'SeachMethods', is 'binary_search'. """

#####################################################
import os


def disk_usage(path):
    """
    An algorithm for computing the cumulative disk space usage nested at a file-system entry.
    Function size returns the immediate disk space of an entry.
    """

    total = os.path.getsize(path)
    if os.path.isdir(path):
        for filename in os.listdir(path):
            child_path = os.path.join(path, filename)
            total += disk_usage(child_path)
    print('{0: < 7}'.format(total), path)
    return total

disk_usage_summary = """    a file system is an implicit example of a data structure known as a tree, and our disk usage
                    algorithm is really a manifestation of a more general algorithm known as a tree traversal.
                    """

#####################################################
fibonacci_instruction = """
    Notice that after computing F(n−2), the call to compute F(n−1) requires its own recursive call to compute F(n−2), as
it does not have knowledge of the value of F(n−2) that was computed at the earlier level of recursion. That is duplicate
work. Worse yet, both of those calls will need to recompute the value of F(n−3), as will the computation of F(n−1). This
snowballing effect is what leads to the exponential running time of bad recursion.
    The bad fibonacci function uses exponential time. We claim that the execution of function efficient fibonacci(n)
takes O(n) time. Each recursive call to good fibonacci decreases the argument n by 1; therefore, a recursion trace
includes a series of n function calls. Because the non-recursive work for each call uses constant time, the overall
computation executes in O(n) time.
"""


def slow_fibonacci(n):
    """Return the nth Fibonacci number."""
    if n <= 1:
        return n
    else:
        return slow_fibonacci(n-2) + slow_fibonacci(n-1)


def efficient_fibonacci(n):
    """Return pair of Fibonacci numbers, F(n) and F(n-1)."""
    if n <= 1:
        return n, 0
    else:
        (a, b) = efficient_fibonacci(n-1)
        return a+b, a


#####################################################

power_instruction = """
    Slow_power call to this version of power(x,n) runs in O(n) time.
    efficient_power perform significantly fewer operations by computing power(x,└n/2┘) as a partial result, and then
multiplying it by itself.
    The efficient_power function results in O(logN) recursive calls
"""


def slow_power(x, n):
    """Compute the value x**n for integer n."""
    if n == 0:
        return 1
    else:
        return x * slow_power(x, n-1)


def efficient_power(x, n):
    """Compute the value x**n for integer n."""
    if n == 0:
        return 1
    else:
        partial = efficient_power(x, n//2)
        result = partial * partial
        if n % 2 == 1:
            result *= x
        return result

#####################################################


def reverse(S, start, stop):
    """Reverse elements in implicit slice S[start:stop]."""
    if start < stop - 1:
        S[start], S[stop-1] = S[stop-1], S[start]
        reverse(S, start + 1, stop-1)

reverse_summary = """
    Total of 1+└n/2┘ recursive calls.the entire process runs in O(n) time.
"""